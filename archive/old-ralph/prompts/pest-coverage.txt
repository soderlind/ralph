@test-coverage-progress.txt

WHAT MAKES A GREAT TEST:
A great test covers behavior users depend on. It tests a feature that, if broken, would frustrate or block users.
It validates real workflows - not implementation details. It catches regressions before users do.
Do NOT write tests just to increase coverage. Use coverage as a guide to find UNTESTED USER-FACING BEHAVIOR.
If uncovered code is not worth testing (boilerplate, unreachable error branches, internal plumbing),
add @codeCoverageIgnoreStart and @codeCoverageIgnoreEnd annotations instead of writing low-value tests.

PROCESS:
1. Run herd coverage ./vendor/bin/pest --coverage --parallel to see which files have low coverage.
2. Read the uncovered lines and identify the most important USER-FACING FEATURE that lacks tests.
    Prioritize: error handling users will hit, controller actions, form requests, service methods, Artisan commands, API endpoints.
    Deprioritize: internal utilities, edge cases users won't encounter, framework boilerplate.
3. Write ONE meaningful Pest test that validates the feature works correctly for users.
4. Run herd coverage ./vendor/bin/pest --coverage --parallel again - coverage should increase as a side effect of testing real behavior.
5. Commit with message: test(<file>): <describe the user behavior being tested>
6. Append super-concise notes to test-coverage-progress.txt: what you tested, coverage %, any learnings.

ONLY WRITE ONE TEST PER ITERATION.
If statement coverage reaches 100%, output <promise>COMPLETE</promise>.
